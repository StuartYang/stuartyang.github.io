<!DOCTYPE html>
<html lang="zh-CN">



  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>
      并发集合 | YangXudong&#39;s Blog
    </title>
    <meta name="description" content="“ 君子藏剑于身，待时而动 ”">
    
      <meta name="keywords" content="
  JUC,集合
  ">
      
        <meta name="author" content="旭东同学">

        <meta http-equiv="Cache-Control" content="no-transform" />
        <meta http-equiv="Cache-Control" content="no-siteapp">
        <meta name="theme-color" content="#1e2327">
        <link rel="apple-touch-icon" href="https://github.githubassets.com/apple-touch-icon.png">
        <link rel="apple-touch-icon" sizes="180x180"
          href="https://github.githubassets.com/apple-touch-icon-180x180.png">

        <link rel="icon" type="image/x-icon" href="https://gitee.com/StuartYang/bpic/raw/master/20210722154537.png">

        <link rel="stylesheet" href="/css/main.css">
        
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="//at.alicdn.com/t/font_2570198_c1noxsh7ksn.css">
        </link>

        <script src="//cdnjs.cloudflare.com/ajax/libs/vue/1.0.25-csp/vue.min.js"></script>
        <!-- JavaScript 日期处理类库 -->
        <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.11.2/moment.min.js"></script>
  <meta name="generator" content="Hexo 5.4.0"></head>

<body id="replica-app">

<nav class="navbar-wrapper">
  <div class="navbar">
    <div class="container clearfix">
      <a href="/" class="navbar-logo"><i class="fa iconfont icon-baiyangzuo" style="font-size: 32px;"></i></a>

      <ul class="navbar-nav float-left">
        
        <li><a href="/archives">文章</a></li>
        
        
        <li><a href="/categories">归档</a></li>
        
        
        <li><a href="/tags">标签</a></li>
        
      </ul>

      <ul class="navbar-nav user-nav float-right desktop-only">
        <li class="user-nav-notification">
          <a><span class="user-nav-unread"></span><i class="fa fa-bell"></i></a>
        </li>
        <li>
          <a><i class="fa fa-plus"></i> <i class="fa fa-caret-down"></i></a>
        </li>
        <li class="user-nav-logo">
          <a><img src="https://gitee.com/StuartYang/bpic/raw/master/20210722154532.jpg"> <i class="fa fa-caret-down"></i></i></a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="main-container">

  <header class="header-wrapper desktop-only">
  <div class="container header-site-detail">
    <ul class="header-toolbar">
      <li class="clearfix">
        <a href="/archives" class="header-toolbar-left"><i
                  class="fa fa-file-text"></i> 文章 </a>
        <a href="/archives"
           class="header-toolbar-right"> 28 </a>
      </li>
      <li>
        <a href="/tags" class="header-toolbar-left"><i
                  class="fa fa-tags"></i> 标签 </a>
        <a href="/tags"
           class="header-toolbar-right"> 31 </a>
      </li>
      <li>
        <a href="/categories" class="header-toolbar-left"><i
                  class="fa fa-folder-open"></i> 归档 </a>
        <a href="/categories"
           class="header-toolbar-right"> 10 </a>
      </li>
    </ul>
    
    <h2 class="header-title">
      <i class="fa fa-book text-muted"></i>
      <a href="/">YangXudong&#39;s Blog</a>
    </h2>
  </div>
</header>


  <div class="post-container container">
    <h3>
      <i class="fa fa-user-o"></i>
      旭东同学

        <span class="post-date float-right"
          title="{{moment(1627580112000).format('MMM DD, YYYY, h:mm:ss A')}}">
          <i class="fa fa-pencil-square-o"></i>
          {{moment(1627580112000).fromNow()}}
        </span>
    </h3>

    <article class="post-content">
      <h1>
        并发集合
      </h1>
      <h2 id="古老的集合"><a href="#古老的集合" class="headerlink" title="古老的集合"></a>古老的集合</h2><h3 id="vector和hashtable"><a href="#vector和hashtable" class="headerlink" title="vector和hashtable"></a>vector和hashtable</h3><p>vector<T>：——线程安全的List</p>
<ul>
<li>大部分的方法synchronized修饰在方法上</li>
</ul>
<p>hashtable&lt;T,V&gt;——线程安全的hashmap</p>
<ul>
<li>大部分的方法synchronized修饰在方法上</li>
</ul>
<h3 id="Collections-synchronized"><a href="#Collections-synchronized" class="headerlink" title="Collections.synchronized*"></a>Collections.synchronized*</h3><ul>
<li><p>hashmap和ArrayList不是线程安全的，但是可以以下方式变得安全</p>
</li>
<li><ul>
<li>Collections.synchronizedList(new ArrayList<E>())</li>
<li>Collections.synchronizedMap(new HashMap&lt;T，E&gt;())</li>
</ul>
</li>
<li><p>Collections.synchronized使用同步代码块的方式</p>
</li>
</ul>
<h2 id="Collection的历史"><a href="#Collection的历史" class="headerlink" title="Collection的历史"></a>Collection的历史</h2><ul>
<li><img src="https://gitee.com/StuartYang/bpic/raw/master/20210730014236.png" alt="image.png"></li>
</ul>
<ul>
<li><p>HashMap：根据object中的hashcode去存储，速度快。</p>
</li>
<li><ul>
<li>线程不安全</li>
<li>key可以一次为null</li>
<li>value可以一直都是null</li>
<li>想线程安全利用前面的两种</li>
<li>满足大多数的使用场景</li>
</ul>
</li>
<li><p><del>Hashtable</del>  </p>
</li>
<li><ul>
<li>和HasMap功能类似</li>
<li>历史遗留类</li>
<li>现在几乎不使用</li>
</ul>
</li>
<li><p>LinkedHashMap</p>
</li>
<li><ul>
<li>HashMap类的子类</li>
<li>保存了数据插入的插入顺序</li>
<li>遍历的顺序和插入顺序一致</li>
</ul>
</li>
<li><p>TreeMap  </p>
</li>
<li><ul>
<li>实现了SortedMap接口</li>
<li>可以根据key去排序（默认升序）</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>V get(Object key)</td>
<td>返回 Map 集合中指定键对象所对应的值。V 表示值的数据类型</td>
</tr>
<tr>
<td>V put(K key, V value)</td>
<td>向 Map 集合中添加键-值对，返回 key 以前对应的 value，如果没有， 则返回 null</td>
</tr>
<tr>
<td>V remove(Object key)</td>
<td>从 Map 集合中删除 key 对应的键-值对，返回 key 对应的 value，如果没有，则返回null</td>
</tr>
<tr>
<td>Set entrySet()</td>
<td>返回 Map 集合中所有键-值对的 Set 集合，此 Set 集合中元素的数据类型为 Map.Entry</td>
</tr>
<tr>
<td>Set keySet()</td>
<td>返回 Map 集合中所有键对象的 Set 集合</td>
</tr>
</tbody></table>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p><strong>为什么不用Collections.synchronizedMap()或者Hashtable？</strong></p>
<p>回答：性能不理想（同步代码块的方式）</p>
<p><strong>为什么说HashMap不安全？</strong></p>
<p>回答：</p>
<ul>
<li><ul>
<li>同时put碰撞导致数据丢失</li>
<li>同时put扩容导致数据丢失</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>扩容后的Map只会保留一个put进去的数据</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>HashMap在高并发下的死循环问题（这个问题发生在JDK7中）<ul>
<li>多个线程同时扩容的时候，会造成循环链表。导致CPU100%。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="HashMap的分析"><a href="#HashMap的分析" class="headerlink" title="HashMap的分析"></a>HashMap的分析</h3><p><strong>解决hash冲突：</strong></p>
<ul>
<li>在JD1.7使用拉链法</li>
<li>在JDK 1.8之后使用拉链法+红黑树。</li>
</ul>
<p><strong>HashMap关于并发的特点</strong></p>
<ol>
<li>非线程安全</li>
<li>迭代是不允许修改内容</li>
<li>只读的并发是安全的</li>
<li>如果一定要把HashMap用在并发环境中，用Collections.synchronizedMap（new HashMap（））</li>
</ol>
<h4 id="ConcurrentHashMap的实现和源码分析（JDK1-7-1-8不同）"><a href="#ConcurrentHashMap的实现和源码分析（JDK1-7-1-8不同）" class="headerlink" title="ConcurrentHashMap的实现和源码分析（JDK1.7 / 1.8不同）"></a>ConcurrentHashMap的实现和源码分析（JDK1.7 / 1.8不同）</h4><h5 id="Java-1-7"><a href="#Java-1-7" class="headerlink" title="Java 1.7"></a>Java 1.7</h5><p><img src="https://gitee.com/StuartYang/bpic/raw/master/20210730015037.png" alt="image-20210730015035779"></p>
<p>入上图所示，ConcurrentHashMap最外层是多个segement，每个segement的底层数据结构仍然是<strong>数组和链表组成拉链法</strong>。</p>
<ul>
<li>每个segement独立上了<strong>ReentrantLock</strong>锁，每个segement相互不影响，提高了并发效率。</li>
<li>默认有16个Segement，所以最多同时支持16个线程并发写，这个默认值可以再初始化的时候进行确定，一旦确定，是不可扩容的。</li>
</ul>
<p>问题：如果多个线程操作同一个segement，仍会发生阻塞。</p>
<p><strong>Put方法流程：</strong></p>
<ol>
<li>为输入的Key做Hash运算，得到hash值。</li>
<li>通过hash值，定位到对应的Segment对象</li>
<li>获取可重入锁</li>
<li>再次通过hash值，定位到Segment当中数组的具体位置。</li>
<li>插入或覆盖HashEntry对象。</li>
<li>释放锁。</li>
</ol>
<p><strong>Get方法：</strong></p>
<ol>
<li>为输入的Key做Hash运算，得到hash值。</li>
<li>通过hash值，定位到对应的Segment对象</li>
<li>再次通过hash值，定位到Segment当中数组的具体位置。</li>
</ol>
<h5 id="Java-1-8"><a href="#Java-1-8" class="headerlink" title="Java 1.8"></a>Java 1.8</h5><ul>
<li>Java 8中对Java 7中的ConcurrentHashMap完全重写，从原来代码量的1000多行直接上升到了6000多行。</li>
<li>Java 8中的ConcurrentHashMap借鉴了Java 7中的HashMap</li>
</ul>
<p><img src="https://gitee.com/StuartYang/bpic/raw/master/20210730015536.jpeg" alt="640?wx_fmt=png"></p>
<p><strong>put源码</strong></p>
<ol>
<li>计算key的hashCode值</li>
<li>如果Map头节点中无该值，利用Unsafe进行CAS操作，将数据放进去</li>
<li>判断<ol>
<li>如果在扩容，就协助扩容</li>
<li>如果Map头节点已经有值了，就解决hash冲突（拉链法/红黑树）<ol>
<li>使用到了synchronized，锁住整个Map头节点<ol>
<li>是链表，就插入<ol>
<li>要插入值在链表中，赋值给oldVal，退出</li>
<li>要插入值不在链表中，把这个新的值放在链表的最后，退出</li>
</ol>
</li>
<li>是红黑树<ol>
<li>将数据插入红黑树，返回oldVal</li>
</ol>
</li>
<li>进行判断：是否需要将链表转成树</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>返回旧值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment">     * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment">     * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment">     * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment">     * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment">     * shrinkage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 链表中长度&gt;= 8，链表转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回值是放进去的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (key, value,<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// oldvalue是put要返回的内容</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">/*1.key或value为null ，抛出空指针异常</span></span><br><span class="line"><span class="comment">    	 *2. hashMap中key允许一个key为null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 得到key的hash值</span></span><br><span class="line">    	<span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();  <span class="comment">// 如果没有这么一个Map就创建</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            case1：Map中没有该数据</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="comment">// 利用Unsafe进行CAS操作，将数据放进去</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,<span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;  <span class="comment">// 成果插入数据，退出         </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            case2：当前Map正在扩容</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)  </span><br><span class="line">                tab = helpTransfer(tab, f); <span class="comment">// 协助扩容</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            case3：当前key的hash处已经有值了。处理hash冲突</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">else</span> &#123;  <span class="comment">// hash冲突</span></span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 使用到了synchronized，锁住整个Node结点</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     case3.1 链表</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;  <span class="comment">// 链表头节点</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">// 链表的操作</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                </span><br><span class="line">                                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                case3.1.1：判断要插入的值是否存在</span></span><br><span class="line"><span class="comment">                                */</span></span><br><span class="line">                                <span class="comment">// 存在，将这个值在链表中找到，赋值给oldVal，退出for方法</span></span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;  </span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                </span><br><span class="line">                                <span class="comment">//  case3.1.2：如果这个值在链表中没有找到，把这个新的值放在链表的最后，退出for方法</span></span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123; <span class="comment">// 节点不存在，添加到链表末尾</span></span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        case3.2 ：红黑树</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 红黑树根节点</span></span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="comment">// putTreeVal(hash, key, value)将数据插入红黑树，返回oldvalue</span></span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                添加之后，会进行判断，是否需要将链表转成树</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD) </span><br><span class="line">                        <span class="comment">// 装成树的方法</span></span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);  <span class="comment">// 统计节点个数，检查是否需要resize</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>get源码</strong></p>
<ol>
<li>计算hashCode</li>
<li>找到对应位置，根据情况进行：<ol>
<li>直接取值</li>
<li>红黑树找值</li>
<li>链表找值</li>
</ol>
</li>
<li>返回结果</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">利用Unsafe方法寻找指定数组在内存中i位置的数据。</span></span><br><span class="line"><span class="comment">CAS</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    	Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; </span><br><span class="line">    	<span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">//计算KEY的hash值</span></span><br><span class="line">        <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">      </span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        e = tabAt(tab, (n - 1) &amp; h)  遍历Map中是否有这么一个相同hash值得Node、</span></span><br><span class="line"><span class="comment">        1. node的引用是不为空 &amp;&amp; node长度不为0 &amp;&amp; node的key存在 ==&gt;找node的hash值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;(e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">//找到了说明值就在node中，直接返回这个值</span></span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果遍历结点的hash值 &lt; 0 ,说明不在node结点上，但是属于这个结点删的元素，&lt;0的信号说明要找的元素在红黑树上</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">            </span><br><span class="line">             <span class="comment">//不在node，也不在红黑树上，只能是在链表上，就去查找链表</span></span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="为什么ConcurrentHashMap要升级？"><a href="#为什么ConcurrentHashMap要升级？" class="headerlink" title="为什么ConcurrentHashMap要升级？"></a>为什么ConcurrentHashMap要升级？</h5><ul>
<li><p>提高了并发性</p>
</li>
<li><ul>
<li>segement—–&gt;Node </li>
</ul>
</li>
<li><ul>
<li><ul>
<li>每个node之间都是独立的</li>
</ul>
</li>
</ul>
</li>
<li><p>hash碰撞</p>
</li>
<li><ul>
<li>拉链法——&gt;拉链法+红黑树</li>
</ul>
</li>
<li><p>保证并发安全</p>
</li>
<li><ul>
<li>由synchronized ——&gt;synchronized锁住Node，CAS进行比较替换数据</li>
</ul>
</li>
<li><p>查询复杂度</p>
</li>
<li><ul>
<li>O(n)——&gt;O(n)+O(logN)</li>
</ul>
</li>
</ul>
<h5 id="为什么数据个数为-8-才转红黑树？"><a href="#为什么数据个数为-8-才转红黑树？" class="headerlink" title="为什么数据个数为 8 才转红黑树？"></a>为什么数据个数为 8 才转红黑树？</h5><ul>
<li><p>红黑树每一个结点的内存大小是链表结点内存大小的 2 倍，所以前期为链表。</p>
</li>
<li><p>泊桑分布查看，发生8次碰撞的可能性非常非常低。如果真的达到8次以上，说明存储的数据可能存在问题，就把链表转为红黑树。</p>
</li>
</ul>
<p>一般情况，是不可能到8的。</p>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><h3 id="集合图鉴"><a href="#集合图鉴" class="headerlink" title="集合图鉴"></a>集合图鉴</h3><ul>
<li><img src="https://gitee.com/StuartYang/bpic/raw/master/20210730014035.png" alt="image-20210730014034537"></li>
</ul>
<p><strong>CopyOnWriteArrayList的说明：</strong></p>
<ul>
<li><p>jdk5以后就有了</p>
</li>
<li><p>用来替代Vector和SynchronizedList</p>
<ul>
<li>Vector和SynchronizedList的粒度太大，并发效率相对比较低并且迭代时无法编辑。</li>
</ul>
</li>
<li><p>Copy-on-Write并发容器还包括CopyOnWriteArraySet，用处来替代同步的HashSet</p>
</li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   或者 CopyOnWriteArrayList&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;(new Integer[]&#123;1,2,3&#125;);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  CopyOnWriteArrayList&lt;Integer&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">12</span>;i++)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    Iterator &lt;Integer&gt; iterager = list.iterager();</span><br><span class="line">    </span><br><span class="line">    whille(iterager.hashNext())&#123;</span><br><span class="line">          System.out.println(list);</span><br><span class="line">        integer next =iterager.next();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        抛出ConCurrentModeficationException</span></span><br><span class="line"><span class="comment">        不能再迭代过程中修改</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(next.equels(<span class="number">2</span>))&#123;</span><br><span class="line">        	 list.remove(<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>读多写少：黑名单，每日更新，监听器：迭代器操作远多于修改操作。</li>
<li>实时性不高的从场合</li>
</ol>
<h3 id="读写规则"><a href="#读写规则" class="headerlink" title="读写规则"></a>读写规则</h3><ul>
<li>CopyOnWriteArrayList在读写锁（读读共享，其他都互斥）上进行升级<ul>
<li>读取是完全不要加锁的，并且更加厉害的是，写入也不会阻塞读取操作，只有写入和写入之间需要同步等待。</li>
<li>读的过程（迭代）中，写入不会阻塞读操作。</li>
</ul>
</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul>
<li><p>Copy-On-Write：写的时候copy一份出来，修改之后将原来的list引用修改过来。</p>
</li>
<li><p>创建新副本，读写分离。</p>
</li>
<li><p>“不可变”原理——旧的容器是不可变的，修改只是先copy在修改。</p>
</li>
<li><p>迭代时候不报错。就是遍历的结果可能是过期的。</p>
</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ul>
<li>写—写之间互斥：ReentrantLock</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span> &lt; <span class="title">E</span> &gt; <span class="keyword">implements</span> <span class="title">List</span> &lt; <span class="title">E</span> &gt; , <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 用transient关键字标记的成员变量不参与序列化过程	</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 用来保存数据的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> object[] array;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            array = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        创建一个空的list</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//1.加锁</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Object[] elements = getArray(); <span class="comment">//2.获得原来的数组</span></span><br><span class="line">            <span class="keyword">int</span> len = elements.length; <span class="comment">//3.获得数组长度</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); <span class="comment">//4.复制到新的数组</span></span><br><span class="line">            newElements[len] = e; <span class="comment">//5.将add的元素添加到新元素</span></span><br><span class="line">            setArray(newElements); <span class="comment">//6.替换之前的数据</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">//7.释放独占锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object[] getArray()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    get方法，可以看到没有任何加锁的过程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) a[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="CopyOnWriteArrayList缺点"><a href="#CopyOnWriteArrayList缺点" class="headerlink" title="CopyOnWriteArrayList缺点"></a>CopyOnWriteArrayList缺点</h3><ul>
<li>数据不一致问题：CopyOnWrite容器只能保证数据的最终一直性，不能保证数据实时一致性。</li>
<li>内存占用问题：因为CopyOnWrite的写死复制机制，所以在进行写操作时，内存会同时驻扎两个对象的机制。</li>
</ul>
<h2 id="ConcurrentHashMap和CopyOnWriteArrayList总结"><a href="#ConcurrentHashMap和CopyOnWriteArrayList总结" class="headerlink" title="ConcurrentHashMap和CopyOnWriteArrayList总结"></a>ConcurrentHashMap和CopyOnWriteArrayList总结</h2><p>取代了<strong>同步的</strong>HashMap和同步的ArrayList（时代巨轮滚滚向前）</p>
<ul>
<li><p>在绝大并发情况下，ConcurrentHashMap和CopyWriteArrayList的性能都更好</p>
</li>
<li><ul>
<li>CopyWriteArrayList<strong>适合读多写少的场景</strong>。</li>
<li><strong>如果List经常被修改，Collections.synchronized会更加有优势。</strong></li>
</ul>
</li>
<li><p>ConcurrentHashMap在Map中无敌。</p>
</li>
</ul>

    </article>
  </div>

</div>


<div class="footer-wrapper container">
  <footer class="footer clearfix">
    <div class="clearfix">
      <a href="https://www.yangxudong.site" class="footer-logo">
        <i class="fa iconfont icon-baiyangzuo" style="font-size: 24px;"></i>
      </a>
      <ul class="footer-social-link">
        <li>© 2019 旭东同学</li>
        <li><a href="https://www.yangxudong.site">Home</a></li>
        
        <li><a target="_blank" rel="noopener" href="https://github.com/StuartYang">Github</a></li>
        
      </ul>
      <div class="footer-theme-info">
        Theme Based on <a target="_blank" rel="noopener" href="//github.com/sabrinaluo/hexo-theme-replica">Replica</a> ❤ Powered by Hexo
      </div>
    </div>
  </footer>
</div>
<script src="/js/main.js"></script>

</body>
</html>
